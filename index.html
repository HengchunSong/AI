<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Pathfinding Search Algorithms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        header {
            text-align: center;
            padding: 20px;
            background-color: #333;
            color: white;
        }
        .container {
            max-width: 1000px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h2 {
            color: #333;
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
        }
        .algorithm {
            margin-bottom: 20px;
        }
        .algorithm h3 {
            color: #0066cc;
        }
        .algorithm p {
            margin: 10px 0;
        }
        code {
            background: #eee;
            padding: 2px 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Introduction to Pathfinding Search Algorithms</h1>
        <p>Explore algorithms used to find optimal paths in graphs or grids</p>
    </header>
    <div class="container">
        <section class="algorithm">
            <h2>Overview</h2>
            <p>Pathfinding algorithms are used to find the shortest or optimal path between two points in a graph or grid, often used in navigation, robotics, and video games. This page introduces common pathfinding algorithms, their mechanisms, and their use cases.</p>
        </section>

        <section class="algorithm">
            <h3>Breadth-First Search (BFS)</h3>
            <p><strong>Description:</strong> BFS explores all neighbors of a node level by level, using a queue. It guarantees the shortest path in unweighted graphs.</p>
            <p><strong>Time Complexity:</strong> O(V + E) - where V is vertices and E is edges.</p>
            <p><strong>Use Case:</strong> Finding the shortest path in mazes or unweighted graphs.</p>
            <p><strong>Pseudocode:</strong></p>
            <pre><code>
function BFS(graph, start, goal):
    queue = new Queue()
    visited = new Set()
    parent = new Map()
    queue.push(start)
    visited.add(start)
    while queue is not empty:
        node = queue.pop()
        if node == goal:
            return reconstruct_path(parent, goal)
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = node
                queue.push(neighbor)
    return null
            </code></pre>
        </section>

        <section class="algorithm">
            <h3>Depth-First Search (DFS)</h3>
            <p><strong>Description:</strong> DFS explores as far as possible along each branch before backtracking, using a stack (or recursion). It may not find the shortest path.</p>
            <p><strong>Time Complexity:</strong> O(V + E).</p>
            <p><strong>Use Case:</strong> Pathfinding in mazes or detecting cycles, but not ideal for shortest paths.</p>
            <p><strong>Pseudocode:</strong></p>
            <pre><code>
function DFS(graph, node, goal, visited, parent):
    if node == goal:
        return reconstruct_path(parent, goal)
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            parent[neighbor] = node
            result = DFS(graph, neighbor, goal, visited, parent)
            if result:
                return result
    return null
            </code></pre>
        </section>

        <section class="algorithm">
            <h3>Uniform Cost Search (UCS)</h3>
            <p><strong>Description:</strong> UCS explores nodes in order of increasing path cost from the start node, using a priority queue. It guarantees the shortest path in weighted graphs with non-negative edge weights.</p>
            <p><strong>Time Complexity:</strong> O((V + E) log V) with a priority queue.</p>
            <p><strong>Use Case:</strong> Finding the shortest path in weighted graphs, such as road networks or resource-constrained routing.</p>
            <p><strong>Pseudocode:</strong></p>
            <pre><code>
function UniformCostSearch(graph, start, goal):
    priority_queue = new PriorityQueue()
    visited = new Set()
    parent = {}
    cost = {start: 0}
    priority_queue.push(start, 0)
    while priority_queue is not empty:
        node = priority_queue.pop()
        if node == goal:
            return reconstruct_path(parent, goal)
        if node not in visited:
            visited.add(node)
            for neighbor, weight in graph[node]:
                new_cost = cost[node] + weight
                if neighbor not in cost or new_cost < cost[neighbor]:
                    cost[neighbor] = new_cost
                    parent[neighbor] = node
                    priority_queue.push(neighbor, new_cost)
    return null
            </code></pre>
        </section>

        <section class="algorithm">
            <h3>Dijkstra’s Algorithm</h3>
            <p><strong>Description:</strong> Dijkstra’s algorithm finds the shortest path in a weighted graph using a priority queue, ensuring non-negative edge weights.</p>
            <p><strong>Time Complexity:</strong> O((V + E) log V) with a priority queue.</p>
            <p><strong>Use Case:</strong> Navigation systems with weighted paths (e.g., road networks).</p>
            <p><strong>Pseudocode:</strong></p>
            <pre><code>
function Dijkstra(graph, start, goal):
    distances = {node: infinity for node in graph}
    distances[start] = 0
    parent = {}
    pq = new PriorityQueue()
    pq.push(start, 0)
    while pq is not empty:
        node = pq.pop()
        if node == goal:
            return reconstruct_path(parent, goal)
        for neighbor, weight in graph[node]:
            if distances[node] + weight < distances[neighbor]:
                distances[neighbor] = distances[node] + weight
                parent[neighbor] = node
                pq.push(neighbor, distances[neighbor])
    return null
            </code></pre>
        </section>

        <section class="algorithm">
            <h3>A* Search</h3>
            <p><strong>Description:</strong> A* is a heuristic-based search that extends Dijkstra’s by using a heuristic to estimate the cost to the goal, prioritizing promising paths.</p>
            <p><strong>Time Complexity:</strong> O(E log V) in practice, depends on heuristic quality.</p>
            <p><strong>Use Case:</strong> Pathfinding in games and robotics with grids or maps.</p>
            <p><strong>Pseudocode:</strong></p>
            <pre><code>
function AStar(graph, start, goal, heuristic):
    open_set = new PriorityQueue()
    open_set.push(start, heuristic(start, goal))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}
    while open_set is not empty:
        current = open_set.pop()
        if current == goal:
            return reconstruct_path(came_from, goal)
        for neighbor in graph[current]:
            tentative_g_score = g_score[current] + distance(current, neighbor)
            if tentative_g_score < g_score.get(neighbor, infinity):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)
                open_set.push(neighbor, f_score[neighbor])
    return null
            </code></pre>
        </section>
    </div>
</body>
</html>
